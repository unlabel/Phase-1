## Ожидание загрузки файлов

Ты уже делал(а) задание c [прогрессбаром](https://github.com/part-time-javascript-elbrus-bootcamp/extra-algorithm-progressbar)? Если еще нет - рекомендуем к нему вернуться позже в свободное время!

Когда пользователь загружает страницу - данные с сервера поступают на клиент асинхронно и неравномерно. Давай смоделируем такое поведение при помощи файловой системы твоего проекта. Тебе предстоит написать progressbar, применимый не к статически заданному времени, а к размеру "загружаемых" файлов. К сожалению, ты пока не сможешь связать свою веб-версию прогрессбара (frontend/client) и работу с файлами (backend/server), однако прогрессбар можно реализовать в консольном виде.

### Release 0. Подготовка файлов

На этом этапе тебе необходимо создать минимум 10 файлов (чем больше - тем интереснее). Наполни эти файлы разным количеством информации. Это может быть одно слово или 20 страниц - все зависит от твоего интереса. Кстати, файлами могут быть даже картинки. Помни, количество информации в каждом файле должно быть разным, чтобы у тебя получились файлы разного размера. Файлы не обязательно должны быть одинакового расширения.

**Совет:** создай файлы в отдельной директории, чтобы там кроме этих файлов ничего не находилось. На самом деле тебе предоставлена папка `files`, в которой уже есть примеры файлов. Пусть эти файлы будут разного размера. Нет необходимости делать их сильно большими.

### Release 1. Синхронный вариант (файл progressbarSync.js)

В этом релизе ты будешь пользоваться синхронными версиями методов fs. Сначала тебе нужно будет получить информацию о файлах, которые лежат в папке `files`. В этом тебе помогут методы:

- fs.readdirSync(path)
- fs.statSync(path)

А теперь для каждого файла нужно будет вызвать функцию `loadFile` (о том как её реализовать написано чуть ниже). После загрузки каждого файла тебе нужно будет обновлять свой progressbar. Чем больше размер файла тем больший кусок должен прибавляться к полоске прогрессбара. То есть, если у тебя есть файл размером 5Кб при общем размере всех файлов - 10 Кб, то твоя полоса загрузки после обработки такого файла должна заполниться на 50% (100% \* (5Кб / 10Кб)).

Теперь о том как реализовать функцию `loadFile`. Во-первых, тебе нужно будет прочитать файл используя метод `fs.readFileSync`. Однако, на современных компьютерах этот метод исполняется молниеносно. Поэтому для того чтобы увидеть как полоска прогрессбара постепенно заполняется, давай добавим искусственную задержку загрузки файла. Для этого тебе нужно будет воспользоваться синхронной версией setTimeout. Возьми её из пакета https://www.npmjs.com/package/wait-sync. Сделай таймаут пропорциональным размеру файла. Тут отталкивайся от размеров своих файлов. Например, можешь сделать так, чтобы 10 KB "загружались" 1 секунду.

### Release 2. Асинхронный вариант с параллельной загрузкой (progressbarParallel.js)

Теперь тебе нужно сделать всё то же самое, но пользуясь асинхронными методами `fs`, а также обычным асинхронным `setTimeout` в функции `loadFile`.

Получить информацию о файлах в папке `files` тебе помогут fs-методы:

- fs.readdir(path)
- fs.stat(path)

Файлы нужно будет загружать параллельно (то есть каждый следующий вызов `loadFile` должен произойти не дожидаясь того пока закончит свою работу предыдущий).

Вот пример того как можно вызывать несколько асинхронных функций параллельно и дождаться пока все они завершат работу:

```js
// Некая асинхронная функция, принимающая callback
function asyncFunction(flag, callback) {
  setTimeout(() => {
    callback(flag * 2);
  }, 100);
}

const flags = [1, 2, 3, 4, 5];
// в этот массив асинхронно должны попасть все числа из массива flags умноженные на два
const results = [];

const totalCallbacksCount = flags.length;
let callbacksCalledCount = 0;

// вызываем асинхронную функцию для каждого флага
for (const flag of flags) {
  asyncFunction(flag, (result) => {
    // когда асинхронная функция закончила свою работу увеличиваем соответствующий счётчик на 1
    callbacksCalledCount++;
    results.push(result);
    // это условие значит, что все асинхронные функции завершили свою работу
    if (callbacksCalledCount === totalCallbacksCount) {
      doSomethingWithFlags(results);
    }
  });
}

function doSomethingWithFlags(results) {
  console.info('Results from all callbacks synchronized:', results);
}
```

Оцени насколько твоя программа начала работать быстрее чем синхронный вариант.

### Release 3. *Опционально:* Асинхронный вариант с последовательной загрузкой (progressbarSequence.js)

Теперь тебе нужно немного переделать твой асинхронный вариант с параллельной загрузкой так чтобы файлы загружались последовательно. Это значит, что каждый вызов функции `loadFile` должен дожидаться пока не закончит свою работу предыдущий.

Вот пример того как можно вызвать последовательно несколько асинхронных функций:

```js
// Некая асинхронная функция, принимающая callback
function asyncFunction(flag, callback) {
  setTimeout(() => {
    callback(flag * 2);
  }, 100);
}

const flags = [1, 2, 3, 4, 5];
// в этот массив асинхронно должны попасть все числа из массива flags умноженные на два
const results = [];

function step(index) {
    // это условие значит, что все асинхронные функции завершили свою работу
  if (index >= flags.length) {
    doSomethingWithFlags(results);
  }
  else {
    const flag = flags[index];
    asyncFunction(flag, (result) => {
      // когда асинхронная функция закончила свою работу увеличиваем соответствующий счётчик на 1
      results.push(result);
      // вызываем асинхронную функцию для следующего значения из массива
      step(index + 1);
    });
  }
}

step(0);

function doSomethingWithFlags(results) {
  console.log('Results from all callbacks synchronized:', results);
}
```

### Release 4. *Опционально:* Зачем же асихронно?

Возможно, ты сделал задание, но так и не понял зачем нужны были асинхронные методы. В таком случае давай сделаем приложение более реалистичным. При запуске программы будет открываться интерактивная консоль. Если ты нажмёшь на любую кнопку на клавиатуре, то консоль напишет тебе: `You pressed the "x" key`. Своего рода минимальное взаимодействие приложения с пользователем. А теперь запусти свою загрузку файлов. Если твоя реализация асинхронна, то ты, может быть, даже не почувствуешь, что программа что-то пытается загрузить. А вот если ты используешь синхронные методы... Тогда ты будешь очень недоволен, что программа так долго не реагирует на твои интенсивные нажатия на кнопки.

## Вывод

Асинхронность - это хорошо. Учись работать с ней, люби её и не обижай!
