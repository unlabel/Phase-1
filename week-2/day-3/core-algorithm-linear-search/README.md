## Упражнения на алгоритмы: Линейный поиск

```javascript
let array = ['A', 'B', 'A'];
// => [A, B, A]
array.indexOf('A');
// => 0
array.indexOf('B');
// => 1
array.indexOf('C');
// => -1
```
*Рисунок 1*. Поиск индекса элемента в массиве.

Тебе необходимо написать метод, который имитирует поведение метода JavaScript `indexOf()`. Этот метод возвращает индекс конкретного элемента в массиве или `-1`, если элемент не найден в массиве. Если элемент найден в массиве более одного раза, то возвращается первый индекс. (см. Рисунок 1)

JS избавляет нас от рутинной работы и низкоуровневого программирования, предоставляя методы, такие как `.indexOf()`. Нам не нужно знать, как находится индекс элемента, нам нужно знать только то, что этот индекс означает и как его использовать в наших программах.

Можно отметить, что это очень хорошо, что JS предоставляет эти абстракции. Тем не менее, мы хотим знать, как реализовать некоторые подобные вещи самому. В этой задаче ты реализуешь работу поиска, используя его конкретный алгоритм - линейный поиск.

## Линейный поиск

В предыдущих задачах ты рассмотрел(а), что существуют разные способы реализации одной и той же задачи, и что существует множество способов поиска данных в коллекции элементов. Понимание различных алгоритмов и шаблонов для поиска и сортировки наборов данных является неотъемлемой частью компьютерных наук.

Одним из основных алгоритмов поиска является линейный поиск. Это алгоритм «грубой силы», где мы просто проверяем каждый элемент по одному разу, пока не найдем элемент, который мы ищем; или просмотрим все элементы и не найдем никакого соответствия.

### Релиз 0. Линейный поиск

```javascript
let numbers = [0, 8, 5, 9, 7, 2];
// => [0, 8, 5, 9, 7, 2]
linearSearch(7, numbers);
// => 4
linearSearch(1, numbers);
// => -1
```
*Рисунок 2*. Пример использования линейного поиска.

Напиши функцию `linearSearch`, которая принимает два аргумента: объект и массив. Она должна последовательно перебирать каждый элемент и возвращать индекс, в котором объект был изначально найден. Если объект не найден, то функция возвращает значение `-1`.

**Тестирование**

Один тест для каждой функции уже написан. Однако тебе нужно больше тестов, чтобы определить, функционирует ли функция согласно твоим ожиданиям. Есть ли какие-либо крайние случаи, которые тебе следует рассмотреть?

Для установки jest - набери  
`npm install`  
Для запуска тестов - набирай  
`npm test`  
в консоле в корне проекта.

Освежи в памяти [тесты](https://github.com/Elbrus-Bootcamp/manuals/blob/master/jasmine.md)

**Ограничения**: Тебе нужно написать функцию, не полагаясь на встроенные методы массива `Enumerable (map/reduce/fiter)`. Единственными свойствами, которыми можно пользоваться для работы с массивами - `Array[]` и `Array.length`. Так же для написания линейного поиска можно использовать циклы `for` и` while`.

### Релиз 1. Глобальный линейный поиск

```javascript
let letters = 'bananas'.split('');
// => ['b', 'a', 'n', 'a', 'n', 'a', 's']
globalLinearSearch('s', letters);
// => [6]
globalLinearSearch('a', letters);
// => [1, 3, 5]
globalLinearSearch('z', letters);
// => []
```
*Рисунок 3*. Пример использования глобального линейного поиска.

В методе `linearSearch` ты возвращаешь индекс первого вхождения элемента. Давай напишем новый метод `globalLinearSearch`, который возвращает массив всех индексов, в которых найден элемент.

На Рисунке 3 приведен пример использования этой функции. Для начала создай тесты для проверки корректной работы, а затем напиши функцию, чтобы протестировать её. Что произойдет, если элемент найден только один раз? И что делать, если он не найден?

## Выводы

Линейный поиск - это один из способов поиска коллекции объектов. Рассмотри производительность своего алгоритма. Как бы он функционировал, если бы было необходимо просмотреть очень большую коллекцию? Допустим, у тебя есть коллекция, содержащая миллион элементов - как бы выполнялся линейный поиск в данном случае?

[wikipedia linear search]: http://en.wikipedia.org/wiki/Linear_search
